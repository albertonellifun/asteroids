<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, xxxmaximum-scale=1.0, xxxuser-scalable=no"/>
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
  <title>Asteroids - Apple ][ clone</title>
  <style>
    html, body {
      margin: 0; height: 100%; 
	  background: #000; 
	  color: #fff;
      font-family: monospace; 
	  display: grid; 
	  place-items: center;
    }
    #view {
      image-rendering: pixelated;
      border: 1px solid #222;
    }
	#scanlines-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      background: repeating-linear-gradient(to right, transparent, transparent 0px, rgba(0, 0, 0, 0.33) 2px, transparent 4px);
      background-size: 100% 4px;
      opacity: 1;
      display:none;
      z-index: 10;
    }
  </style>
</head>
<body>

<div id="scanlines-overlay"></div>
<canvas id="view" width="840" height="576"></canvas>

<script>
(function(){
  //apple ][ hgr/hgr2
  const BASE_W = 280;
  const BASE_H = 192;
  const SCALE = 3;

  //offscreen per disegnare alla risoluzione base
  const off = document.createElement('canvas');
  off.width = BASE_W; 
  off.height = BASE_H;
  const octx = off.getContext('2d', { alpha: false });

  //canvas di visualizzazione
  const view = document.getElementById('view');
  view.width = BASE_W * SCALE; 
  view.height = BASE_H * SCALE;
  const vctx = view.getContext('2d', { alpha: false });
  vctx.imageSmoothingEnabled = false;

  //palette
  const COLORS = {
    BLACK:  { dark: '#000', light: '#444' },
    WHITE:  { dark: '#bbb', light: '#fff' },
	GREEN:  { dark: '#0a0', light: '#5f5' },
	PURPLE: { dark: '#c0c', light: '#f0f' },
	GRAY:   { dark: '#666', light: '#999' },
	ORANGE: { dark: '#f80', light: '#fa2' },//il miglior arancione del mondo
    BLUE:   { dark: '#00a', light: '#00e' },
	RED:    { dark: '#a00',	light: '#f55' },
	CYAN:   { dark: '#0aa',	light: '#5ff' },
	MAGENTA: { dark: '#a0a', light: '#f5f'},
	BROWN:   { dark: '#c90', light: '#ff5'},
	PARTICLE: { dark: '#0c0', light:'#5f5'},
	BULLET: { dark: '#ccc', light: '#fff' }
  };

  let score = 0;
  let godMode = false;//per debug
  let bw = true;//tutto verde o a colori?
  let fill = false;//riempimento asteroidi
  let scanLinesEnabled = false;//a noi piacciono i monitor vintage
  
  let isMute = true;//perche' il silenzio e' d'oro
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();//definito una sola volta
  
  let texture = false;//asteroidi testurizzati
  let rockTexture = null;
  
  //controlli input
  const keys = new Set();
  window.addEventListener('keydown', (e)=> {
    keys.add(e.code);
	
	if(keys.has('KeyR')) { resetGame(); keys.delete('KeyR'); playBeep(); }
	if(keys.has('KeyB')) { bw = !bw; keys.delete('KeyB'); }
	if(keys.has('KeyF')) { fill = !fill; keys.delete('KeyF'); }
	if(keys.has('KeyG')) { godMode = !godMode; keys.delete('KeyG'); }
	if(keys.has('KeyT')) { texture = !texture; keys.delete('KeyT'); }
	if(keys.has('KeyP')) { paused = !paused; keys.delete('KeyP'); }
	if(keys.has('KeyM')) { isMute = !isMute; keys.delete('KeyM'); }
	if(keys.has('KeyS')) { scanLinesEnabled = !scanLinesEnabled; keys.delete('KeyS'); 
	  if (scanLinesEnabled) document.getElementById('scanlines-overlay').style.display = 'block';
	  else document.getElementById('scanlines-overlay').style.display = 'none';
	}	
	
    //evita scrolling con arrow/space
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  }, { passive: false });
  window.addEventListener('keyup', (e)=> keys.delete(e.code));

  //utils
  const rand = (min, max)=> Math.random()*(max-min)+min;
  const wrap = (x, max)=> (x<0)? x+max : (x>=max)? x-max : x;

  //navetta triangolare
  class Ship {
    constructor(color){
      this.x = BASE_W/2; this.y = BASE_H/2;
      this.vx = 0; this.vy = 0;
      this.angle = -Math.PI/2; // punta verso l'alto
      this.radius = 8;
      this.cooldown = 0;
	  this.alive = true;
	  this.color = color;
    }
	
    update(dt){
	  if(!this.alive) return;
	  
      const ROT = 3.2;      // rad/s
      const THRUST = 60;    // px/s^2
      const MAXV = 140;     // clamp per controllo

      if(keys.has('ArrowLeft'))  this.angle -= ROT*dt;
      if(keys.has('ArrowRight')) this.angle += ROT*dt;
      if(keys.has('ArrowUp')) {
        this.vx += Math.cos(this.angle) * THRUST * dt;
        this.vy += Math.sin(this.angle) * THRUST * dt;
      }

      const spd = Math.hypot(this.vx,this.vy);
      if(spd > MAXV){ const k = MAXV/spd; this.vx*=k; this.vy*=k; }

      this.x = wrap(this.x + this.vx*dt, BASE_W);
      this.y = wrap(this.y + this.vy*dt, BASE_H);

      this.cooldown = Math.max(0, this.cooldown - dt);
      if(keys.has('Space') && this.cooldown === 0){
        this.cooldown = 0.15;
        bullets.push(new Bullet(this.x, this.y, this.angle, Math.hypot(this.vx,this.vy), this.color));
		playShootSound();
      }
    }
	
	render(ctx){
      if(this.alive) {
	    //render navetta sdraiata
	    ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.beginPath();
        ctx.moveTo(7, 0);     //punta
        ctx.lineTo(-6, -4);   //sinistra
	    ctx.lineTo(-4, 0);    //rientranza
        ctx.lineTo(-6, 4);    //destra
        ctx.closePath();
        ctx.strokeStyle = this.color.dark;
        ctx.lineWidth = 1;
		if(fill) { 
		    const grad = ctx.createLinearGradient(0, -4, 0, 4);
            grad.addColorStop(0, this.color.light);
			grad.addColorStop(0.55, this.color.dark);
			grad.addColorStop(1, this.color.dark);
		    ctx.fillStyle = grad;//this.color.light; 
			ctx.fill(); 
		}
        ctx.stroke();
		
		
		if (godMode) {
		  //campo di forza verdastro
		  ctx.strokeStyle = COLORS.GREEN.light;
		  ctx.beginPath();
		  ctx.setLineDash([2,1]);
		  ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
		  ctx.closePath();
		  ctx.stroke();
		  ctx.setLineDash([]);
		}
		
		ctx.restore();
	  }
    }
  }

  
  //esplosione in mille pezzettini
  function explodeShip(ship){
    // particelle della nave (bianco + arancione)
    for(let i=0;i<40;i++){
      const a = Math.random() * Math.PI*2;
      const sp = rand(40, 160);
      const vx = Math.cos(a)*sp, vy = Math.sin(a)*sp;
      const life = rand(0.3, 0.8);
      particles.push(new Particle(ship.x, ship.y, vx, vy, life, ship.color));
    }
    ship.alive = false;
  }



  //asteroidi
  class Asteroid {
    constructor(x,y,size=5,color){
      this.x=x; this.y=y;
      this.size = size; //5=xl, 4=l, 3=m, 2=s, 1=xs
      const speed = rand(15, 45) / size;
      const a = rand(0, Math.PI*2);
      this.vx = Math.cos(a)*speed;
      this.vy = Math.sin(a)*speed;
      this.angle = rand(0, Math.PI*2);
      this.spin = rand(-0.6, 0.6);
      this.radius = size*5;//raggio per bounding
      const sides = Math.floor(rand(6, 6+size*2)); // almeno 6 lati
      this.poly = makeAsteroidPolygon(sides, this.radius, this.radius*0.4);
      this.color = color;
    }
    update(dt){
      this.x = wrap(this.x + this.vx*dt, BASE_W);
      this.y = wrap(this.y + this.vy*dt, BASE_H);
      this.angle += this.spin*dt;
    }
    render(ctx){
	  ctx.save();
	  ctx.translate(this.x, this.y);
      
	  //shadow
	  if(fill){
	    let delta = {x: -3, y:-1};
		ctx.beginPath();
        const p0 = rotatePoint(this.poly[0], this.angle);
        ctx.moveTo(p0.x + delta.x, p0.y + delta.y);

        for(let i=1; i<this.poly.length; i++){
          const p = rotatePoint(this.poly[i], this.angle);
          ctx.lineTo(p.x + delta.x, p.y + delta.y);
        }
		
        ctx.closePath();
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
	    ctx.fill();
	  }
	  
	  ctx.rotate(this.angle);
	  
	  
	  //outer
      ctx.beginPath();
      ctx.moveTo(this.poly[0].x, this.poly[0].y);
      for (let i = 1; i < this.poly.length; i++) {
        ctx.lineTo(this.poly[i].x, this.poly[i].y);
      }
      ctx.closePath();
      ctx.strokeStyle = this.color.dark;
      ctx.lineWidth = 1;
	  
	  if(fill) { 
	    
		

		
		const grad = ctx.createRadialGradient(
          -this.radius*0.3, -this.radius*0.3, this.radius*0.2,
          0, 0, this.radius*1.2);
		grad.addColorStop(0, this.color.light);
        grad.addColorStop(1, this.color.dark);
		
		ctx.fillStyle = grad;//this.color.light; 
		ctx.fill();
		
		if(texture) {
		  ctx.globalCompositeOperation = "luminosity";//"multiply";//multiply diventa trasparente
		  ctx.fillStyle = rockTexture;
		  ctx.fill();
		  ctx.globalCompositeOperation = "source-over";
		}
		
		
	  }
	  
      ctx.stroke();
	  
	  
	  
	  //dimensione
	  ctx.fillStyle = this.color.dark;
	  ctx.font = (7 + this.size) + 'px monospace';
	  ctx.fillText(this.size, -2, 2);
	  
	  ctx.restore();
    }
  }

  function makeAsteroidPolygon(sides = 8, radius = 20, jitter = 6) {
    const pts = [];
    for (let i = 0; i < sides; i++) {
      const angle = (i / sides) * Math.PI * 2;
      const r = radius + (Math.random() * jitter - jitter / 3);
      pts.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
    }
    return pts;
  }
  
  function rotatePoint(p, angle){
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return {
      x: p.x * cos - p.y * sin,
      y: p.x * sin + p.y * cos
    };
  }
  
  

  function generateRockTexture() {
      const c = document.createElement("canvas");
      c.width = 10;
      c.height = 10;
      const ctx = c.getContext("2d");
      const colors = [ "#ccc", "#999", "#666", "#333" ];
  
      //disegna puntini random
      for (let i = 0; i < 75; i++) {
          const x = rand(0, 10);
          const y = rand(0, 10);
          ctx.fillStyle = colors[Math.floor(rand(0, colors.length))];
          ctx.fillRect(x, y, 1, 1);
      }
      return ctx.createPattern(c, "repeat");
  }
  
  
  
  //proiettili
  class Bullet {
    constructor(x,y,angle,shipSpeed,color){
      const SPEED = 180;
      this.x=x; this.y=y;
      this.vx = Math.cos(angle)*SPEED + (shipSpeed? Math.cos(angle)*shipSpeed*0.2 : 0);
      this.vy = Math.sin(angle)*SPEED + (shipSpeed? Math.sin(angle)*shipSpeed*0.2 : 0);
      this.life = 0.9;
      this.radius = 1.5;
      this.color = color;
    }
    update(dt){
      this.x = wrap(this.x + this.vx*dt, BASE_W);
      this.y = wrap(this.y + this.vy*dt, BASE_H);
      this.life -= dt;
    }
    render(ctx){
	  ctx.strokeStyle = this.color.dark;
      ctx.fillStyle = this.color.light;
      ctx.fillRect(this.x-1, this.y-1, 2, 2);
	  ctx.strokeRect(this.x-1, this.y-1, 2, 2);
    }
  }



  //particelle per le esplosioni :P
  class Particle {
    constructor(x,y,vx,vy,life,color){
      this.x=x; 
	  this.y=y; 
	  this.vx=vx; 
	  this.vy=vy; 
	  this.life=life; 
	  this.color=color;
    }
    update(dt){
      this.x = wrap(this.x + this.vx*dt, BASE_W);
      this.y = wrap(this.y + this.vy*dt, BASE_H);
      this.life -= dt;
    }
    render(ctx){
      if(this.life<=0) return;
      ctx.fillStyle = this.vx*this.vy > 0 ? this.color.light : this.color.dark;
      ctx.fillRect(this.x, this.y, 1, 1);
    }
  }



  //ufo... i cattivi
  class EnemyShip {
    constructor(color){
      // spawn ai bordi
      this.x = (Math.random()<0.5)? 0 : BASE_W;
      this.y = rand(20, BASE_H-20);
      this.vx = (this.x===0)? 40 : -40; // entra da sinistra o destra
      this.vy = rand(-20,20);
      this.radius = 10;
      this.cooldown = 1.5; // tempo tra colpi
      this.alive = true;
      this.color = color;
    }
    update(dt){
      if(!this.alive) return;
      this.x = wrap(this.x + this.vx*dt, BASE_W);
      this.y = wrap(this.y + this.vy*dt, BASE_H);
  
      this.cooldown -= dt;
      if(this.cooldown<=0){
        this.cooldown = 1.5;
        this.shoot();
      }
    }
    shoot(){
      // mira verso la nave
      const dx = ship.x - this.x;
      const dy = ship.y - this.y;
      const a = Math.atan2(dy, dx);
      enemyBullets.push(new EnemyBullet(this.x, this.y, a, this.color));
	  playShootSound();
    }
    render(ctx){
      if(!this.alive) return;
	  
	  ctx.save();
      ctx.translate(this.x, this.y);
      ctx.strokeStyle = this.color.dark;
      
	  //navetta tipo invaders modificata
	  //cupola
	  ctx.beginPath();
	  ctx.ellipse(0, 0, 10, 5, 0, Math.PI, 2 * Math.PI);
	  ctx.closePath();
	  if(fill) { ctx.fillStyle = this.color.light; ctx.fill(); }
	  ctx.stroke();
	  
	  //triangoli sotto
	  /*
	  ctx.beginPath();
	  ctx.moveTo(-10,0);
	  ctx.lineTo(-6,3);
	  ctx.lineTo(-2,0);
	  ctx.lineTo(-10,0);
	  ctx.closePath();
	  
	  ctx.beginPath();
	  ctx.moveTo(10,0);
	  ctx.lineTo(6,3);
	  ctx.lineTo(2,0);
	  ctx.lineTo(10,0);
	  ctx.closePath();
	  if(fill) { ctx.fillStyle = this.color.light; ctx.fill(); }
	  ctx.stroke();
	  */
	  ctx.beginPath();
	  ctx.ellipse(0, 0, 5, 3, 0, 0, Math.PI);
	  ctx.closePath
	  if(fill) { ctx.fillStyle = this.color.light; ctx.fill(); }
	  ctx.stroke();	

	  ctx.beginPath();
	  ctx.ellipse(0, 0, 7, 7, 0, Math.PI * 1.25, 1.75 * Math.PI);
	  ctx.closePath
	  if(fill) { ctx.fillStyle = this.color.light; ctx.fill(); }
	  ctx.stroke();	  	  
	  
	  
	  
	  //quadratini/finestrelle in mezzo
	  const seconds = new Date().getSeconds() % 3;
	  for(let i=0;i<4;i++) {
	    if(fill) { ctx.fillStyle = COLORS.BLACK.dark; ctx.fillRect(-8+i*5 + seconds, -2, 2, 2); }
		ctx.strokeRect(-9 + i*5 + seconds, -2, 2, 2);
	  }
	  
      ctx.restore();
    }
  }



  //i cattivi sparano!
  class EnemyBullet {
    constructor(x,y,angle,color){
      const SPEED = 100;
      this.x=x; 
	  this.y=y;
      this.vx = Math.cos(angle)*SPEED;
      this.vy = Math.sin(angle)*SPEED;
      this.life = 1.8;
      this.radius = 1.5;
      this.color = color;
    }
    update(dt){
      this.x = wrap(this.x + this.vx*dt, BASE_W);
      this.y = wrap(this.y + this.vy*dt, BASE_H);
      this.life -= dt;
    }
    render(ctx){
      ctx.fillStyle = this.color.light;
      ctx.fillRect(this.x-1,this.y-1,2,2);
    }
  }



  //stelline in cielo 
  class Star {
    constructor(x, y, size, color) {
	  this.x = x;
	  this.y = y;
	  this.size = size;
	  this.color = color;
	}
	
	render(ctx) {
	  ctx.fillStyle = this.color.light;
	  ctx.fillRect(this.x, this.y, this.size, this.size);
	}
  }
  
  //stato del gioco
  const ship = new Ship(COLORS.WHITE);
  const rocks = [];
  const bullets = [];
  const particles = [];
  const enemies = [];
  const enemyBullets = [];
  const stars = [];



  function randomColor() {
    if(bw) return COLORS.GREEN;
    const values = Object.values(COLORS);// array di valori (#hex)
	const idx = rand(2, values.length) | 0;
    return values[idx];
  }

  function spawnAsteroids(count) {
    for(let i=0;i<count;i++){
      let x = rand(0, BASE_W);
	  let y = rand(0, BASE_H);
      if(Math.hypot(x-ship.x,y-ship.y)<40){ i--; continue; }
      const r = new Asteroid(x, y, 5-i, randomColor());
      rocks.push(r);
    }
  }
  
  function spawnStars(count = 50) {
	for(let i=0; i < count; i++) {
	  stars.push(new Star(rand(0,BASE_W),rand(0,BASE_H),Math.random()<0.2?2:1,COLORS.GRAY));
	}
  }

  //collisioni
  function hitCircle(a,b){
    const dx=a.x-b.x;//distanza x
	const dy=a.y-b.y;//distanza y
    const ar = a.radius;//raggio a
	const br = b.radius;//raggio b
    return (dx*dx+dy*dy) <= (ar+br)*(ar+br);
  }

  //divide l'asteroide solo se e' abbastanza grande
  function splitRock(rock){
    if(rock.size>1){
	
	
	  //direzione del colpo -> centro asteroide
	  let dx = rock.x - ship.x;
      let dy = rock.y - ship.y;
	  
	  //normalizzata
	  const len = Math.hypot(dx, dy);
      dx /= len;
      dy /= len;
	  
	  //questa e' la normale/perpendicolare
	  let nx = -dy;
      let ny = dx;
	  
	  //normalizzata
	  const nlen = Math.hypot(nx, ny);
      nx /= nlen;
      ny /= nlen;
		
	  const angle = rand(0, Math.PI * 2);  // direzione casuale
	  const dist  = rock.radius * 0.5;           // distanza iniziale
	  const parentSpeed = Math.hypot(rock.vx, rock.vy); //velocita padre
	  
	  for(let i=0;i<2;i++){
        const dir = (i === 0 ? 1 : -1);
		const px = rock.x + nx * dist * dir;
        const py = rock.y + ny * dist * dir;
		const r = new Asteroid(px, py, rock.size - 1, rock.color);
		
		r.vx = rock.vx + nx * dir * parentSpeed * rand(1,2);
        r.vy = rock.vy + ny * dir * parentSpeed * rand(1,2);
		
		//const r = new Asteroid(rock.x, rock.y, rock.size-1, rock.color);
        //r.vx += rand(-30,30); 
		//r.vy += rand(-30,30);
				
        rocks.push(r);
      }
    }
  }


  function resetGame(baseScore = 0){
    ship.x=BASE_W/2; 
	ship.y=BASE_H/2;
    ship.vx=0;
	ship.vy=0; 
	ship.angle=-Math.PI/2;
	ship.alive=true;
	rocks.length=0; 
	bullets.length=0; 
	particles.length=0;
	enemies.length=0;
	enemyBullets.length=0;
    spawnAsteroids(3);
	score = baseScore;
	stars.length=0;
	spawnStars(50);
	rockTexture = generateRockTexture();
  }

  //loop
  let last = performance.now();
  let paused = false;
  
  function frame(now){
    const dt = Math.min(1/30, (now-last)/1000); 
	last = now;
    if(!paused) update(dt);
    render();
    requestAnimationFrame(frame);
  }

  //tick di update
  function update(dt){
    ship.update(dt);
    rocks.forEach(r=>r.update(dt));
    bullets.forEach(b=>b.update(dt));
    particles.forEach(p=>p.update(dt));
    enemies.forEach(e=>e.update(dt));
    enemyBullets.forEach(b=>b.update(dt));


	//arrivano gli ufo cattivoni
	if(enemies.length < 2 && Math.random()>0.999) {
		enemies.push(new EnemyShip( bw ? COLORS.PURPLE : randomColor(0) ));
	}


	//proiettili nave vs ufo
	for(let bi=bullets.length-1; bi>=0; bi--){
	  const b = bullets[bi];
	  for(let ei=enemies.length-1; ei>=0; ei--){
		const e = enemies[ei];
		if(e.alive && hitCircle(b,e)){
		  score += 10;
		  bullets.splice(bi,1);
		  e.alive=false;
		  // esplosione
		  playShipExplosionSound();
		  for(let i=0;i<20;i++){
			particles.push(new Particle(e.x,e.y,rand(-80,80),rand(-80,80),rand(0.2,0.6), e.color));
		  }
		}
	  }
	}

	//proiettili ufo vs nave
	for(let bi=enemyBullets.length-1; bi>=0; bi--){
	  const b = enemyBullets[bi];
	  if(b.life<=0){ enemyBullets.splice(bi,1); continue; }
	  if(!godMode && ship.alive && hitCircle(ship,b)){
		explodeShip(ship);
		playShipExplosionSound();
		setTimeout(function(){ resetGame(); },1000);
	  }
	}

    //bullet vs rocks
    for(let bi=bullets.length-1; bi>=0; bi--){
      const b = bullets[bi];
      if(b.life<=0){ bullets.splice(bi,1); continue; }
      for(let ri=rocks.length-1; ri>=0; ri--){
        const r = rocks[ri];
        if(hitCircle(b, r)){
		  score += 6 - r.size;
		  bullets.splice(bi,1);
          rocks.splice(ri,1);
          splitRock(r);
          //esplosione
          for(let i=0;i<20;i++){
            particles.push(
				new Particle(r.x, r.y, rand(-60,60), rand(-60,60), rand(0.1,0.4), r.color));
          }
		  playExplosionSound();
          break;
        }
      }
    }

    //ship vs rocks
	if(ship.alive) {
      for(const r of rocks){
        if(!godMode && hitCircle(ship, r)){
		  explodeShip(ship);
		  playShipExplosionSound();
          setTimeout(function(){ resetGame(); },1000);
          break;
        }
	  }
    }

    //cull particles
    for(let i=particles.length-1;i>=0;i--){
      if(particles[i].life<=0) particles.splice(i,1);
    }
	
	if(rocks.length === 0) setTimeout(function(){ resetGame(score); },1000);
  }


  //render scena
  function render(){
    //clear offscreen
    octx.fillStyle = COLORS.BLACK.dark;
    octx.fillRect(0,0,BASE_W,BASE_H);

	//stelle
	stars.forEach(s=>s.render(octx));

    //draw all objects
    rocks.forEach(r=>r.render(octx));
    bullets.forEach(b=>b.render(octx));
    particles.forEach(p=>p.render(octx));
    ship.render(octx);
	
	//ufo
	enemies.forEach(e=>e.render(octx));
    enemyBullets.forEach(b=>b.render(octx));
	
    //HUD
	octx.font = '10px monospace';
	octx.fillStyle = COLORS.WHITE.light;
	octx.fillText('SCORE ' + score.toString().padStart(4, '0'), 0, 10);
	
	octx.font = '8px monospace';
	octx.fillStyle = COLORS.BLACK.light;
	octx.fillText('ASTEROIDS - Apple ][ clone', BASE_W - 116, 10);
	function decodeBool(x) { return x ? '1' : '0'; }
	let testo = '[B]w:'+ decodeBool(bw);
	testo += ' ';
	testo += '[F]ill:'+ decodeBool(fill);
	testo += ' ';
	testo += '[T]exture:'+ decodeBool(texture);
	testo += ' ';
	testo += '[G]od:'+ decodeBool(godMode);
	testo += ' ';
	testo += '[M]ute:'+ decodeBool(isMute);
	testo += ' ';
	testo += '[S]can:'+ decodeBool(scanLinesEnabled);
	testo += ' ';
	testo += '[R]eset';
	octx.fillText(testo, 0, BASE_H - 2);
	
    //blit con nearest-neighbor
    vctx.clearRect(0,0,view.width,view.height);
    vctx.drawImage(off, 0, 0, view.width, view.height);
  }
  
  
  
//SUONI presi in prestito da artillery clone per apple ][
function playExplosionSound() {
  if(isMute) return;
  const now = audioCtx.currentTime;

  // 1. Crea un generatore di Rumore Bianco (Noise Buffer)
  const bufferSize = audioCtx.sampleRate * 0.5; // 0.5 secondi
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    output[i] = Math.random() * 2 - 1; // Riempie il buffer con rumore casuale (statico)
  }

  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;

  // 2. Crea i nodi di Guadagno e Filtro
  const noiseGain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();

  // Imposta il filtro per un suono "sordo" e breve (filtro passa basso)
  filter.type = 'lowpass';
  filter.frequency.setValueAtTime(1000, now); // Frequenza di taglio iniziale
  filter.frequency.exponentialRampToValueAtTime(10, now + 0.3); // Decadimento rapido della frequenza

  // Connessioni: Rumore -> Filtro -> Guadagno -> Destinazione
  noise.connect(filter);
  filter.connect(noiseGain);
  noiseGain.connect(audioCtx.destination);

  // 3. Envelope (ADSR)
  noiseGain.gain.setValueAtTime(0.5, now); // Volume iniziale
  // Decay rapido del volume (il "botto" finisce subito)
  noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3); 

  // 4. Avvia e Ferma
  noise.start(now);
  noise.stop(now + 0.3);
}

function playShootSound() {
  if(isMute) return;
    // 1. Crea l'oscillatore (il "generatore di suono")
    const oscillator = audioCtx.createOscillator();
    // Usa un'onda quadra per un suono "pixelato" o un'onda a dente di sega (sawtooth)
    oscillator.type = 'square'; 

    // 2. Crea un nodo del guadagno (Gain Node) per controllare il volume e l'ADSR
    const gainNode = audioCtx.createGain();
    
    // Connetti: Oscillatore -> Guadagno -> Destinazione (altoparlanti)
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    // 3. Imposta la Frequenza Iniziale e Finale (per il "pitch-drop" o "fall")
    const startFreq = 400; // Frequenza iniziale (più alta)
    const endFreq = 200;   // Frequenza finale (più bassa)
    const duration = 0.15; // Durata breve in secondi

    oscillator.frequency.setValueAtTime(startFreq, now);
    // Diminuisci rapidamente la frequenza (effetto laser/sparo 8-bit)
    oscillator.frequency.exponentialRampToValueAtTime(endFreq, now + duration);

    // 4. Imposta il Volume (Envelope)
    gainNode.gain.setValueAtTime(0.5, now); // Volume iniziale
    // Riduci rapidamente il volume
    gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration); 
    
    // 5. Avvia e Ferma l'oscillatore
    oscillator.start(now);
    oscillator.stop(now + duration);
}

function playShipExplosionSound() {
  if(isMute) return;
    const now = audioCtx.currentTime;
    const duration = 0.5; // Durata maggiore per l'esplosione del carro armato

    // 1. Rumore Bianco (Il "Bot")
    const bufferSize = audioCtx.sampleRate * duration;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const output = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1; 
    }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;

    const noiseGain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(2000, now);
    filter.frequency.exponentialRampToValueAtTime(10, now + duration);

    noise.connect(filter);
    filter.connect(noiseGain);
    
    // 2. Tono Basso (L'effetto "WAAAH")
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'sawtooth'; // Tono più ricco di armoniche
    
    const oscGain = audioCtx.createGain();
    
    // Connessioni per il Tono:
    oscillator.connect(oscGain);

    // Envelope del Tono: Pitch Drop
    oscillator.frequency.setValueAtTime(100, now); // Frequenza iniziale bassa
    oscillator.frequency.exponentialRampToValueAtTime(10, now + duration); // Crolla a 10Hz

    // 3. Unione e Decadimento del Guadagno
    
    // Volume del Rumore
    noiseGain.gain.setValueAtTime(0.6, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + duration); 

    // Volume del Tono
    oscGain.gain.setValueAtTime(0.3, now);
    oscGain.gain.exponentialRampToValueAtTime(0.001, now + duration); 

    // Unisci i due suoni e invia alla destinazione
    noiseGain.connect(audioCtx.destination);
    oscGain.connect(audioCtx.destination);

    // 4. Avvia e Ferma
    noise.start(now);
    noise.stop(now + duration);
    oscillator.start(now);
    oscillator.stop(now + duration);
}

function playBeep() {
  if(isMute) return;
  const oscillator = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  oscillator.type = 'square'; // Apple II usava un'onda quadra
  oscillator.frequency.setValueAtTime(935, audioCtx.currentTime);
  gain.gain.setValueAtTime(0.2, audioCtx.currentTime);

  oscillator.connect(gain);
  gain.connect(audioCtx.destination);

  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.1); // durata 250 ms
}
  
  
  
  
  
  
  
  
  
  
  

  rockTexture = generateRockTexture();
  spawnAsteroids(3);
  spawnStars(50);
  
  requestAnimationFrame(frame);
})();
</script>

</body>
</html>